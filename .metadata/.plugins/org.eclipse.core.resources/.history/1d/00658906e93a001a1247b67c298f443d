/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * main entry point for hacky Scopy tests
 */

#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>

#include "platform.h"
#include "xil_printf.h"
#include "xil_types.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "xil_testmem.h"
#include "xuartps_hw.h"
#include "xgpiops.h"
#include "xaxidma.h"
#include "xscugic.h"
#include "xdebug.h"

uint32_t *mem_addr;
uint32_t *base;

#define PACKET_MAXSIZE		16383

// These MUST be on 1MB boundaries to allow the cache to be invalidated safely
// and they MUST be integer MB in size
uint8_t rx_buffer[1048576] __attribute__((aligned (1048576))) __attribute__((section("ddr3")));
uint8_t tx_buffer[1048576] __attribute__((aligned (1048576))) __attribute__((section("ddr3")));

//#define MEM_TEST

XAxiDma dma0_pointer;
XAxiDma_Config *dma0_config;
XGpioPs gpio;
XGpioPs_Config *gpio_config;

volatile uint32_t ioc_flag = 0;

#define MARK_UNCACHEABLE	0x701

void debug_printf(char *fmt, ...)
{
	char buffer[1024];

	va_list args;
	va_start(args, fmt);

	vsnprintf(buffer, 1024, fmt, args);
	print(buffer);

	va_end(args);
}

void arb_delay(uint32_t n)
{
	while(n--) {
		__asm__("nop");
	}
}


/*
 * For hacking/test purposes.
 * (C) Xilinx, Inc. https://www.xilinx.com/Attachment/xaxidma_example_sg_intr.c
 */
#define INTC					XScuGic
#define INTC_HANDLER			XScuGic_InterruptHandler
#define RESET_TIMEOUT_COUNTER	10000

#define RX_INTR_ID				XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID
#define TX_INTR_ID				XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID

#define INTC_DEVICE_ID          XPAR_SCUGIC_SINGLE_DEVICE_ID

static INTC Intc;	/* Instance of the Interrupt Controller */

static void RxIntrHandler(void *Callback)
{
	XAxiDma_BdRing *RxRingPtr = (XAxiDma_BdRing *) Callback;
	u32 IrqStatus;
	u32 AxiStatus;
	int TimeOut;

	/* Read pending interrupts */
	IrqStatus = XAxiDma_BdRingGetIrq(RxRingPtr);

	/* ACK at DMA peripheral. */
	XAxiDma_IntrAckIrq(&dma0_pointer, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

	/* Acknowledge pending interrupts */
	XAxiDma_BdRingAckIrq(RxRingPtr, IrqStatus);

	debug_printf("irq=0x%08x\r\n", IrqStatus);

	/*
	 * If no interrupt is asserted, we do not do anything
	 */
	if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK)) {
		debug_printf("NoIRQ?\r\n");
		return;
	}

	/*
	 * If error interrupt is asserted, raise error flag, reset the
	 * hardware to recover from the error, and return with no further
	 * processing.
	 */
#if 0
	if ((IrqStatus & XAXIDMA_IRQ_ERROR_MASK)) {
		debug_printf("ErrorMask?\r\n");

		/*
		 * Ignore DataMover error.  It's caused by not handling TLAST correctly which will be fixed in a
		 * later ADC controller version.
		 */
		AxiStatus = XAxiDma_ReadReg(RxRingPtr->ChanBase, XAXIDMA_SR_OFFSET);
		if (AxiStatus & (XAXIDMA_ERR_ALL_MASK & (~XAXIDMA_ERR_INTERNAL_MASK))) {
			XAxiDma_BdRingDumpRegs(RxRingPtr);

			/* Reset could fail and hang
			 * NEED a way to handle this or do not call it??
			 */
			XAxiDma_Reset(&dma0_pointer);

			TimeOut = RESET_TIMEOUT_COUNTER;

			while (TimeOut) {
				if(XAxiDma_ResetIsDone(&dma0_pointer)) {
					break;
				}

				TimeOut -= 1;
			}

			debug_printf("RST timeout=%d\r\n", TimeOut);

			return;
		}
	}
#endif

	/*
	 * If completion interrupt is asserted, call RX call back function
	 * to handle the processed BDs and then raise the according flag.
	 */
	if ((IrqStatus & (XAXIDMA_IRQ_DELAY_MASK | XAXIDMA_IRQ_IOC_MASK))) {
		debug_printf("IOC!\r\n");
		ioc_flag = 1;
	}
}

static int SetupIntrSystem(INTC * IntcInstancePtr,
			   XAxiDma * AxiDmaPtr, u16 TxIntrId, u16 RxIntrId)
{
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(AxiDmaPtr);
	XAxiDma_BdRing *RxRingPtr = XAxiDma_GetRxRing(AxiDmaPtr);
	int Status;

	XScuGic_Config *IntcConfig;


	/*
	 * Initialize the interrupt controller driver so that it is ready to
	 * use.
	 */
	IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
	if (NULL == IntcConfig) {
		return XST_FAILURE;
	}

	Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig,
					IntcConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}


	//XScuGic_SetPriorityTriggerType(IntcInstancePtr, TxIntrId, 0xA0, 0x3);

	XScuGic_SetPriorityTriggerType(IntcInstancePtr, RxIntrId, 0xA0, 0x3);

	/*
	 * Connect the device driver handler that will be called when an
	 * interrupt for the device occurs, the handler defined above performs
	 * the specific interrupt processing for the device.
	 */
	/*
	Status = XScuGic_Connect(IntcInstancePtr, TxIntrId,
				(Xil_InterruptHandler)TxIntrHandler,
				TxRingPtr);
	if (Status != XST_SUCCESS) {
		return Status;
	}
	*/

	Status = XScuGic_Connect(IntcInstancePtr, RxIntrId,
				(Xil_InterruptHandler)RxIntrHandler,
				RxRingPtr);
	if (Status != XST_SUCCESS) {
		return Status;
	}

	//XScuGic_Enable(IntcInstancePtr, TxIntrId);
	XScuGic_Enable(IntcInstancePtr, RxIntrId);

	/* Enable interrupts from the hardware */

	Xil_ExceptionInit();
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
			(Xil_ExceptionHandler)INTC_HANDLER,
			(void *)IntcInstancePtr);

	Xil_ExceptionEnable();

	return XST_SUCCESS;
}

int main()
{
	uint32_t counter = 0;
	int32_t error;

    init_platform();

	debug_printf("\033[2J\033[0m");
	debug_printf("\r\n\r\nDemoApp v1.0 - DMA controlled transfers\r\n");

	dma0_config = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
	error = XAxiDma_CfgInitialize(&dma0_pointer, dma0_config);

	debug_printf("XAxiDma_CfgInitialize error=%d\r\n", error);

	debug_printf("TXBuff Addr=0x%08x\r\n", &tx_buffer);
	debug_printf("RXBuff Addr=0x%08x\r\n", &rx_buffer);

	// Enable interrupts, we use interrupt mode
	SetupIntrSystem(&Intc, &dma0_pointer, TX_INTR_ID, RX_INTR_ID);

	// Disable IRQ first then enable it
	XAxiDma_IntrDisable(&dma0_pointer, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);
	XAxiDma_IntrEnable(&dma0_pointer, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);

	debug_printf("OK, done.\r\n");

	while(1) {
		counter = 0;

		error = XAxiDma_SimpleTransfer(&dma0_pointer, (uint8_t *) rx_buffer, 262140, XAXIDMA_DEVICE_TO_DMA);
		Xil_DCacheInvalidateRange(rx_buffer, PACKET_MAXSIZE);

		debug_printf("Waiting...\r\n");

		while(!ioc_flag) {
			counter++;
		}
		ioc_flag = 0;

		debug_printf("Transfer done, cycles=%d.\r\n", counter);

		//error = XAxiDma_CfgInitialize(&dma0_pointer, dma0_config);

		XAxiDma_Reset(&dma0_pointer);

		// Enable interrupts, we use interrupt mode
		SetupIntrSystem(&Intc, &dma0_pointer, TX_INTR_ID, RX_INTR_ID);

		XAxiDma_IntrDisable(&dma0_pointer, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
		XAxiDma_IntrEnable(&dma0_pointer, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
	}

    cleanup_platform();

    return 0;
}
